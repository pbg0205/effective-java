예전에 처음 자바의 정석을 보면서 extends 키워드와 함께 상속이라는 단어를 보았다. 흔히 상속이라는 의미는 부모의 것을 물려받는다는 의미로 인식한다. 하지만 자바에서의 상속은 물려받는 의미보다 계층관계를 통해 분류하는 의미로 사용하는 것이 더욱 적합하다. 단순히 클래스의 기능 확장을 목적으로 하는 상속은 캡슐화를 무너뜨릴 수 있다.

왜 상속보다는 컴포지션을 사용해야 할까? 그 이전에 오버라이드에 관한 이야기를 언급하고자 한다. 오버라이드는 부모의 메서드를 덮어씌우고 자기에 맞는 로직을 작성하겠다는 의미이다. 비록 상속관계를 인지한 개발자는 이전의 로직에서 조금 더 확장한 의미로 사용하겠지만 이는 정말 위험하다. 오늘 스프링 고급편 강의를 들으며 김영한님께서는 제약을 고려한 설계는 좋은 설계라고 이야기한다. 개발자는 실수를 할 수 있으며 제약을 할 수 있는 설계는 미연의 실수를 방지할 수 있는 좋은 방법이라고 하셨다. 하지만 오버라이드는 오히려 제약을 하기는 커녕 오히려 제약을 무너뜨리는 역할을 한다. 올바르지 못한 로직의 상속은 연쇄적으로 자식의 로직에도 영향을 미치고 원인을 정확히 파악하지 못한채 자식 메서드에서 버그를 수정했다 하더라도 상위 부모 메서드의 버그는 해결하지 못한 채로 존재하기 때문이다.

그렇다고 상속이 단점만 존재하는 것은 아니다. 코드의 재사용을 줄이고 규약을 지정하거나 부모의 기능을 확장할 수 있다. 그렇다면 아마 의문을 품을 것이다. ‘방금 전까지 기능 확장을 위해서 상속을 하지 말라고 하더니!’라고 생각할 수 있다. 내가 이야기하고 싶은 것은 상속의 정확한 목적을 가지고 사용하자는 의미이다.

책에서도 언급했듯이 상속을 사용할 때는 is-a 관계일 때 사용하는 것을 권고한다. 하지만 is-a의 의미로는 잘 와닿지 않았다. 오히려 [자식 is kind of 부모]와 같은 관계가 성립할 경우에 사용하는 것이 캡슐화를 유지할 수 있는 방법인 것 같다. 자바책에서 또한 주된 예제들이 위와 같은 계층구조를 띈 상속관계를 언급하고 있다. 포유류(부모)-강아지(자식), 조류(부모)-새(자식)과 같은 말그대로 상위 클래스가 추상화된 개념으로 더욱 많이 쓰이고 있어 웬만하면 계층관계를 띄고 있는 경우가 아니라면 합성(composition)관계를 사용하도록 하자.

스프링에서 또한 DI를 사용할 때, 합성관계를 사용할 것은 권고한다. 심지어 인텔리제이를 사용할 떄 @Autowired를 사용하면 생성자 주입으로 변경하라는 경고문이 나온다. 이는 합성 관계를 사용했을 때 유지보수에 이점을 가져다 주기 때문에 스프링이 선택한 방법 중 하나이다. 상위 클래스를 인터페이스로 정의하고 세부 기능 변경이 필요한 순간 단순히 구현체만 변경할 수 있 유연하게 변경하여 기능을 확장할 수 있는 장점이 있다. 스프링은 철저하게 OCP를 만족하며 유지 보수를 위해 전략패턴을 선택한 것이 분명하다. 그러니까 결론은 합성을 사용하자.